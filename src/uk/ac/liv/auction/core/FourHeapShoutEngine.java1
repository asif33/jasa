package uk.ac.liv.auction.core;

import uk.ac.liv.auction.agent.TraderAgent;

import uk.ac.liv.util.BinaryHeap;
import uk.ac.liv.util.QueueDisassembler;
import uk.ac.liv.util.PriorityQueue;
import uk.ac.liv.util.Debug;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Comparator;

import java.io.PrintStream;
import java.io.Serializable;

/**
 * <p>
 * This class provides auction shout management services using the 4-Heap algorithm
 * presented in the paper:
 * </p>
 *
 * <p>
 * "Flexible Double Auctions for Electronic Commerce: Theory and Implementation"
 * by Wurman, Walsh amnd Wellman 1998.
 * </p>
 *
 * <p>
 * All state is maintained in memory resident data structures and no crash recovery
 * is provided.
 * </p>
 */

public class FourHeapShoutEngine implements ShoutEngine, Serializable {

  /**
   * Matched bids in ascending order
   */
  private BinaryHeap bIn;

  /**
   * Unmatched bids in descending order
   */
  private BinaryHeap bOut;

  /**
   * Matched asks in descending order
   */
  private BinaryHeap sIn;

  /**
   * Unmatched asks in ascending order
   */
  private BinaryHeap sOut;

  protected static AscendingShoutComparator greaterThan =
    new AscendingShoutComparator();

  protected static DescendingShoutComparator lessThan =
    new DescendingShoutComparator();

  String state0, state1;

  public FourHeapShoutEngine() {
    initialise();
  }

  public synchronized void removeShout( Shout shout ) {
    checkBalanced();
    if ( shout.isAsk() ) {
      removeAsk(shout);
    } else {
      removeBid(shout);
    }
    checkBalanced();
  }

  protected void removeAsk( Shout shout ) {
    if ( sIn.remove(shout) ) {
      balance(bIn,bOut,shout.getQuantity());
    } else {
      sOut.remove(shout);
    }
  }

  protected void removeBid( Shout shout ) {
    if ( bIn.remove(shout) ) {
      balance(sIn,sOut,shout.getQuantity());
    } else {
      bOut.remove(shout);
    }
  }

  public String toString() {
    return "sIn = " + sIn + "\nbIn = " + bIn + "\nsOut = " + sOut + "\nbOut = " + bOut;
  }

  /**
   * Log the current state of the auction.
   */
  public void printState() {
    //checkBalanced();
    System.out.println(this.toString());
  }


  /**
   * Insert a shout into a binary heap.
   *
   * @param heap  The heap to insert into
   * @param shout The shout to insert
   *
   */
  private static void insertShout( BinaryHeap heap, Shout shout ) throws DuplicateShoutException {
    try {
      heap.insert(shout);
    } catch ( IllegalArgumentException e ) {
      throw new DuplicateShoutException("Duplicate shout: " + shout.toString());
    }
  }


  /**
   * Insert a matched ask into the appropriate heap
   */
  private void insertMatchedAsk( Shout ask ) throws DuplicateShoutException {
    insertShout(sIn, ask);
  }

  /**
   * Insert a matched bid into the appropriate heap.
   */
  private void insertMatchedBid( Shout bid ) throws DuplicateShoutException {
    insertShout(bIn, bid);
  }

  /**
   * Insert an unmatched ask into the approriate heap.
   */
  public void insertUnmatchedAsk( Shout ask ) throws DuplicateShoutException {
    insertShout(sOut, ask);
  }

  /**
   * Insert an unmatched bid into the approriate heap.
   */
  public void insertUnmatchedBid( Shout bid ) throws DuplicateShoutException {
    insertShout(bOut, bid);
  }

  /**
   * Get the highest unmatched bid.
   */
  public Shout getHighestUnmatchedBid() {
    return (Shout) bOut.getFirst();
  }


  /**
   * Get the lowest matched bid
   */
  public Shout getLowestMatchedBid() {
    return (Shout) bIn.getFirst();
  }

  /**
   * Get the lowest unmatched ask.
   */
  public Shout getLowestUnmatchedAsk() {
    return (Shout) sOut.getFirst();
  }

  /**
   * Get the highest matched ask.
   */
  public Shout getHighestMatchedAsk() {
    return (Shout) sIn.getFirst();
  }

  public void displaceLowestMatchedBid( Shout bid ) throws DuplicateShoutException {
    checkBalanced();
    state0 = toString();
    int nB = bid.getQuantity();
    int qtyTransfered = balance(bIn, bOut, nB, lessThan, bid);
    insertMatchedBid(bid);
    state1 = toString();
    int shortFall = nB - qtyTransfered;
    if ( shortFall > 0 ) {
      int qtyTransfered2 = balance(sOut, sIn, shortFall, lessThan, bid);
      if ( qtyTransfered2 < shortFall ) {
        criticalBalance(bIn, bOut, shortFall - qtyTransfered2);
      }
    }
    checkBalanced();
  }

  public void displaceHighestMatchedAsk( Shout ask ) throws DuplicateShoutException {
    checkBalanced();
    state0 = toString();
    int nS = ask.getQuantity();
    int qtyTransfered = balance(sIn, sOut, nS, greaterThan, ask);
    insertMatchedAsk(ask);
    state1 = toString();
    int shortFall = nS - qtyTransfered;
    if ( shortFall > 0 ) {
      int qtyTransfered2 = balance(bOut, bIn, shortFall, greaterThan, ask);
      if ( qtyTransfered2 < shortFall ) {
        criticalBalance(sIn, sOut, shortFall - qtyTransfered2);
      }
    }
    checkBalanced();
  }


  public void promoteHighestUnmatchedBid( Shout ask ) throws DuplicateShoutException {
    checkBalanced();
    state0 = toString();
    // ask is about to be inserted into sIn
    // Are we going to have n(sIn) > n(bIn)
    int nS = ask.getQuantity();
    insertMatchedAsk(ask);
    int qtyTransfered = balance(bOut, bIn, nS, greaterThan, ask);
    state1 = toString();
    if ( qtyTransfered < nS ) {
      criticalBalance(sIn, sOut, nS-qtyTransfered);
    }
    checkBalanced();
  }

  public void promoteLowestUnmatchedAsk( Shout bid ) throws DuplicateShoutException {
    checkBalanced();
    state0 = toString();
    int nB = bid.getQuantity();
    insertMatchedBid(bid);
    int qtyTransfered = balance(sOut, sIn, nB, lessThan, bid);
    state1 = toString();
    if ( qtyTransfered < nB ) {
      criticalBalance(bIn, bOut, nB-qtyTransfered);
    }
    checkBalanced();
  }

  protected Iterator matchedBidDisassembler() {
    return new QueueDisassembler(bIn);
  }

  protected Iterator matchedAskDisassembler() {
    return new QueueDisassembler(sIn);
  }

  private void checkBalanced() {
    int nS = countQty(sIn);
    int nB = countQty(bIn);
    if ( nS != nB ) {
      printState();
      throw new Error("shout heaps not balanced nS="+nS + " nB=" + nB);
    }
    Shout bInTop = (Shout) bIn.getFirst();
    Shout sInTop = (Shout) sIn.getFirst();
    Shout bOutTop = (Shout) bOut.getFirst();
    Shout sOutTop = (Shout) sOut.getFirst();
/*
    System.out.println("bInTop = " + bInTop);
    System.out.println("sInTop = " + sInTop);
    System.out.println("bOutTop = " + bOutTop);
    System.out.println("sOutTop = " + sOutTop);
*/
    checkBalanced(bInTop, bOutTop, "bIn >= bOut");
    checkBalanced(sOutTop, sInTop, "sOut >= sIn");
    checkBalanced(sOutTop, bOutTop, "sOut >= bOut");
    checkBalanced(bInTop, sInTop, "bIn >= sIn");

/*    if ( bOutTop != null && !(bOutTop.getPrice() >= sOutTop.getPrice()) ) {
      System.out.println("bid = " + bOutTop);
      System.out.println("ask = " + sOutTop);
      Debug.assert( bOutTop.getPrice() >= sOutTop.getPrice() );
    } */

  }

  public void checkBalanced( Shout s1, Shout s2, String condition ) {
    if ( !((s1 == null || s2 == null) || s1.getPrice() >= s2.getPrice()) ) {
      System.out.println("state0");
      System.out.println(state0);
      System.out.println("state1");
      System.out.println(state1);
      System.out.println("state2");
      printState();
      System.out.println("shout1 = " + s1);
      System.out.println("shout2 = " + s2);
      throw new Error("Heaps not balanced! - " + condition);
    }
  }

  /**
   * <p>
   * Return a list of matched bids and asks.  The list is of the form
   * </p><br>
   *
   *   ( b0, a0, b1, a1 .. bn, an )<br>
   *
   * <p>
   * where bi is the ith bid and a0 is the ith ask.  A typical auctioneer would
   * clear by matching bi with ai for all i at some price.</p>
   */
  public List getMatchedShouts() {
    LinkedList result = new LinkedList();
    while ( ! sIn.isEmpty() ) {
      Debug.assert("count(bIn) != count(sIn)", ! bIn.isEmpty());
      Shout sInTop = (Shout) sIn.removeFirst();
      Shout bInTop = (Shout) bIn.removeFirst();
      //checkBalanced();
      //Debug.assert( bInTop.getPrice() >= sInTop.getPrice() );
      int nS = sInTop.getQuantity();
      int nB = bInTop.getQuantity();
      if ( nS < nB ) {
        // split the bid
        Shout remainder = bInTop.split(nB-nS);
        bIn.insert(remainder);
      } else if ( nB < nS ) {
        // split the ask
        Shout remainder = sInTop.split(nS-nB);
        sIn.insert(remainder);
      }
      result.add(bInTop);
      result.add(sInTop);
    }
    return result;
  }

  protected void initialise() {
    bIn   = new BinaryHeap(greaterThan);
    bOut  = new BinaryHeap(lessThan);
    sIn   = new BinaryHeap(lessThan);
    sOut  = new BinaryHeap(greaterThan);
  }

  public synchronized void reset() {
    initialise();
  }

  private static int countQty( BinaryHeap heap ) {
    Iterator i = heap.iterator();
    int qty = 0;
    while ( i.hasNext() ) {
      Shout s = (Shout) i.next();
      qty += s.getQuantity();
    }
    return qty;
  }

  private static void criticalBalance( BinaryHeap from, BinaryHeap to,
                                        int qtyDesired, Comparator comparator,
                                        Shout criteriaShout ) {
    int transfered = balance(from, to, qtyDesired, comparator, criteriaShout);
    Debug.assert("Cannot balance heaps", transfered == qtyDesired);
  }


  private static void criticalBalance( BinaryHeap from, BinaryHeap to, int qtyDesired ) {
    criticalBalance(from, to, qtyDesired, null, null);
  }

  private static int balance( BinaryHeap from, BinaryHeap to, int qtyDesired ) {
    return balance(from, to, qtyDesired, null, null);
  }

  private static int balance( BinaryHeap from, BinaryHeap to, int qtyDesired,
                                Comparator comparator, Shout criteriaShout ) {

    int qtyTransfered = 0;

    transferLoop: while ( qtyTransfered < qtyDesired ) {

      if ( from.isEmpty() ) {
        break transferLoop;
      }

      Shout s;

      // peek at the next shout and check criteria, if any, is met
      if ( comparator != null ) {
        s = (Shout) from.getFirst();
        if ( comparator.compare(s, criteriaShout) < 0 ) {
         break transferLoop;
        }
      }

      s = (Shout) from.removeFirst();
      int qty = s.getQuantity();
      if ( qty + qtyTransfered > qtyDesired ) {
        int qtyExtra = qty+qtyTransfered-qtyDesired;
        Shout r = s.split(qtyExtra);
        from.insert(r);
        qtyTransfered += qty - qtyExtra;
      } else {
        qtyTransfered += qty;
      }
      try {
        to.insert(s);
      } catch ( IllegalArgumentException e ) {
        throw new IllegalArgumentException("Duplicate shout encountered whilst trying to balance heaps.");
      }
    }

    return qtyTransfered;
  }


}